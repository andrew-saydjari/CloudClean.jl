<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · CloudClean.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CloudClean.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Covariance-Construction-Functions"><span>Covariance Construction Functions</span></a></li><li><a class="tocitem" href="#Per-Location-Functions"><span>Per Location Functions</span></a></li><li><a class="tocitem" href="#Image-Preprocessing"><span>Image Preprocessing</span></a></li><li><a class="tocitem" href="#Full-Image-Processing-Functions"><span>Full Image Processing Functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/andrew-saydjari/CloudClean.jl/blob/main/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Covariance-Construction-Functions"><a class="docs-heading-anchor" href="#Covariance-Construction-Functions">Covariance Construction Functions</a><a id="Covariance-Construction-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Covariance-Construction-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CloudClean.cov_avg!" href="#CloudClean.cov_avg!"><code>CloudClean.cov_avg!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cov_avg!(bimage, ism, bism, in_image; Np::Int=33, widx::Int=129, widy::Int=129, ftype::Int=32)</code></pre><p>Key function for constructing the (shifted and multiplied) versions of the input image used to quickly estimate the local covariance matrix at a large number of locations. The main output is in the preallocated <code>bism</code> which is used as an input to <code>build_cov!</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>bimage</code>: preallocated output array for the boxcar smoothed unshifted image</li><li><code>ism</code>: preallocated intermediate array for the input image times itself shifted</li><li><code>bism</code>: preallocated output array to store boxcar-smoothed image products for all shifts</li><li><code>in_image</code>: input image the local covariance of which we want to estimate</li></ul><p><strong>Keywords:</strong></p><ul><li><code>Np::Int</code>: size of local covariance matrix in pixels (default 33)</li><li><code>widx::Int</code>: width of boxcar window in x which determines size of region used for samples for the local covariance estimate (default 129)</li><li><code>widy::Int</code>: width of boxcar window in y which determines size of region used for samples for the local covariance estimate (default 129)</li><li><code>ftype::Int</code>: determine the Float precision, 32 is Float32, otherwise Float64</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudClean.jl/blob/0b5d67ae6d3498b479a5fd1eb28c0e8a01de2cd1/src/cov.jl#L79-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudClean.boxsmooth!" href="#CloudClean.boxsmooth!"><code>CloudClean.boxsmooth!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">boxsmooth!(out::AbstractArray, arr::AbstractArray, tot::Array{T,1}, widx::Int, widy::Int)</code></pre><p>Boxcar smooths an input image (or paddedview) <code>arr</code> with window size <code>widx</code> by <code>widy</code>. We pass the original image size <code>sx</code> and <code>sy</code> to help handle image views.</p><p><strong>Arguments:</strong></p><ul><li><code>out::AbstractArray</code>: preallocated output array for the boxcar smoothed image</li><li><code>arr::AbstractArray</code>: input array for which boxcar smoothing is computed (generally paddedview)</li><li><code>tot::Array{T,1}</code>: preallocated array to hold moving sums along 1 dimension</li><li><code>widx::Int</code>: size of boxcar smoothing window in x</li><li><code>widy::Int</code>: size of boxcar smoothing window in y</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudClean.jl/blob/0b5d67ae6d3498b479a5fd1eb28c0e8a01de2cd1/src/cov.jl#L36-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudClean.outest_bounds" href="#CloudClean.outest_bounds"><code>CloudClean.outest_bounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">outest_bounds(cx,sx) -&gt; px0</code></pre><p>Helper function to find maximum padding in pixels required to accomodate all query points <code>cx</code> outside of the image size 1:<code>sx</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>cx</code>: list of integer star centers (in either x or y)</li><li><code>sx</code>: image dimension along the axis indexed by <code>cx</code></li></ul><p><strong>Outputs:</strong></p><ul><li><code>px0</code>: maximum padding in pixels required to accomodate all query points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudClean.jl/blob/0b5d67ae6d3498b479a5fd1eb28c0e8a01de2cd1/src/cov.jl#L10-L21">source</a></section></article><h2 id="Per-Location-Functions"><a class="docs-heading-anchor" href="#Per-Location-Functions">Per Location Functions</a><a id="Per-Location-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Per-Location-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CloudClean.gen_pix_mask_trivial" href="#CloudClean.gen_pix_mask_trivial"><code>CloudClean.gen_pix_mask_trivial</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gen_pix_mask_trivial(kmasked2d; Np=33) -&gt; kstar, kcond</code></pre><p>Flatten a pixel mask and calculate the number of pixels used for the conditional infill.</p><p><strong>Arguments:</strong></p><ul><li><code>kmasked2d</code>: A 2D array representing the masked pixels.</li></ul><p><strong>Keywords:</strong></p><ul><li><code>Np</code>: An optional integer specifying the number of pixels in a side (default: 33).</li></ul><p><strong>Returns:</strong></p><ul><li><code>kstar</code>: A flattened version of the input <code>kmasked2d</code> array.</li><li><code>kcond</code>: The count of unmasked pixels in the <code>kstar</code> array.</li></ul><p><strong>Examples:</strong></p><pre><code class="language-julia hljs">julia&gt; kmasked2d = rand(Bool, 33, 33)
julia&gt; kstar, kcond = gen_pix_mask_trivial(kmasked2d, Np=33)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudClean.jl/blob/0b5d67ae6d3498b479a5fd1eb28c0e8a01de2cd1/src/per_loc.jl#L8-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudClean.gen_pix_mask_circ" href="#CloudClean.gen_pix_mask_circ"><code>CloudClean.gen_pix_mask_circ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gen_pix_mask_circ(kmasked2d, circmask; Np=33) -&gt; kstar, kcond</code></pre><p>Generate a circular pixel mask and calculate the number of pixels used for the conditional infill.</p><p><strong>Arguments:</strong></p><ul><li><code>kmasked2d</code>: A 2D array representing the masked pixels.</li><li><code>circmask</code>: A 2D array representing the circular mask.</li></ul><p><strong>Keywords:</strong></p><ul><li><code>Np</code>: An optional integer specifying the number of pixels in a side (default: 33).</li></ul><p><strong>Returns:</strong></p><ul><li><code>kstar</code>: A copy of the input <code>kmasked2d</code> array with circular masking applied.</li><li><code>kcond</code>: The count of unmasked pixels in the <code>kstar</code> array.</li></ul><p><strong>Examples:</strong></p><p><code>julia julia&gt; kmasked2d = rand(Bool, 33, 33) julia&gt; circmask = kstar_circle_mask(33,rlim=256) julia&gt; kstar, kcond = gen_pix_mask_circ(kmasked2d, circmask, Np=33)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudClean.jl/blob/0b5d67ae6d3498b479a5fd1eb28c0e8a01de2cd1/src/per_loc.jl#L36-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudClean.condCovEst_wdiag" href="#CloudClean.condCovEst_wdiag"><code>CloudClean.condCovEst_wdiag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">condCovEst_wdiag(cov_loc,μ,km,data_in;Np=33,export_mean=false,n_draw=0) -&gt; out</code></pre><p>Using a local covariance matrix estimate <code>cov_loc</code> and a set of known (&quot;good&quot;) pixels <code>km</code>, this function computes a prediction for the mean value of masked pixels and the covariance matrix of the masked pixels. The output list can conditionally include the mean reconstruction and draws from the distribution of reconstructions.</p><p><strong>Arguments:</strong></p><ul><li><code>cov_loc</code>: local covariance matrix</li><li><code>μ</code>: vector containing mean value for each pixel in the patch</li><li><code>km</code>: unmasked pixels</li><li><code>data_in</code>: input image</li></ul><p><strong>Keywords:</strong></p><ul><li><code>Np</code>: size of local covariance matrix in pixels (default 33)</li><li><code>export_mean</code>: when true, returns the mean conditional prediction for the &quot;hidden&quot; pixels (default false)</li><li><code>n_draw</code>: when nonzero, returns that number of realizations of the conditional infilling (default 0)</li></ul><p><strong>Outputs:</strong></p><ul><li><code>out[1]</code>: input image returned with masked pixels replaced with mean prediction</li><li><code>out[2]</code>: input image returned with masked pixels replaced with a draw from the predicted distribution</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudClean.jl/blob/0b5d67ae6d3498b479a5fd1eb28c0e8a01de2cd1/src/per_loc.jl#L66-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudClean.build_cov!" href="#CloudClean.build_cov!"><code>CloudClean.build_cov!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">build_cov!(cov::Array{T,2},μ::Array{T,1},cx::Int,cy::Int,bimage::Array{T,2},bism::Array{T,4},Np::Int,widx::Int,widy::Int) where T &lt;:Union{Float32,Float64}</code></pre><p>Constructs the local covariance matrix and mean for an image patch of size <code>Np</code> x <code>Np</code> pixels around a location of interest (<code>cx</code>,<code>cy</code>). The construction is just a lookup of pixel values from the stored boxcar-smoothed copies of the input image times itself shifted in <code>bism</code>. Passing the smoothed image <code>bimage</code> and the widths of the boxcar mean <code>widx</code> and <code>widy</code> is helpful for the mean and normalization. The covariance and mean are updated in place for speed since this operation may be performed billions of times since we construct a new covariance matrix for every detection. Math may either be performed <code>Float32</code> or <code>Float64</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>cov::Array{T,2}</code>: preallocated output array for local covariance matrix</li><li><code>μ::Array{T,1}</code>: preallocated output vector for local mean</li><li><code>cx::Int</code>: x-coordinate of the center of the local region</li><li><code>cy::Int</code>: y-coordinate of the center of the local region</li><li><code>bimage::Array{T,2}</code>: boxcar smoothed unshifted image</li><li><code>bism::Array{T,4}</code>: boxcar-smoothed image products for all shifts</li><li><code>Np::Int</code>: size of local covariance matrix in pixels</li><li><code>widx::Int</code>: width of boxcar window in x which determines size of region used for samples for the local covariance estimate</li><li><code>widy::Int</code>: width of boxcar window in y which determines size of region used for samples for the local covariance estimate</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudClean.jl/blob/0b5d67ae6d3498b479a5fd1eb28c0e8a01de2cd1/src/per_loc.jl#L121-L141">source</a></section></article><h2 id="Image-Preprocessing"><a class="docs-heading-anchor" href="#Image-Preprocessing">Image Preprocessing</a><a id="Image-Preprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Image-Preprocessing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CloudClean.prelim_infill!" href="#CloudClean.prelim_infill!"><code>CloudClean.prelim_infill!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">prelim_infill!(testim,bmaskim,bimage,bimageI,testim2,bmaskim2,goodpix;widx=19,widy=19,ftype::Int=32,widmult=1.4)</code></pre><p>This intial infill replaces masked pixels with a guess based on a smoothed boxcar. For large masked regions, the smoothing scale is increased. If this iteration takes too long/requires too strong of masking, the masked pixels are replaced with the median of the image.</p><p>We use 3 copies of the input image and mask image. The first is a view (with reflective boundary condition padding) with the pixels to be infilled replaced with zeros, the second is allocated to hold various smoothings of the image, and the third holds the output image which contains our best infill guess. A final Bool array of size corresponding to the image is used to keep track of pixels that have safe infill values.</p><p><strong>Arguments:</strong></p><ul><li><code>testim</code>: input image which requires infilling</li><li><code>bmaskim</code>: input mask indicating which pixels require infilling</li><li><code>bimage</code>: preallocated array for smoothed version of input image</li><li><code>bimageI</code>: preallocated array for smoothed mask counting the samples for each estimate</li><li><code>testim2</code>: inplace modified ouptut array for infilled version of image input</li><li><code>bmaskim2</code>: inplace modified mask to keep track of which pixels still need infilling</li><li><code>goodpix</code>: preallocated array for Bool indexing pixels with good infill</li></ul><p><strong>Keywords:</strong></p><ul><li><code>widx</code>: initial size of boxcar smoothing window in x (default 19)</li><li><code>widy</code>: initial size of boxcar smoothing window in y (default 19)</li><li><code>ftype::Int</code>: determine the Float precision, 32 is Float32, otherwise Float64</li><li><code>widmult</code>: multiplicative factor for increasing the smoothing scale at each iteration step</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudClean.jl/blob/0b5d67ae6d3498b479a5fd1eb28c0e8a01de2cd1/src/preprocess.jl#L168-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudClean.sig_iqr" href="#CloudClean.sig_iqr"><code>CloudClean.sig_iqr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sig_iqr(x)</code></pre><p>Calculate the normalized interquartile range (IQR) of an array as a robust measure of standard deviation.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: A 1D array or iterable.</li></ul><p><strong>Returns</strong></p><ul><li>The normalized IQR, computed as the IQR divided by 1.34896.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; x = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
julia&gt; result = sig_iqr(x)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudClean.jl/blob/0b5d67ae6d3498b479a5fd1eb28c0e8a01de2cd1/src/preprocess.jl#L11-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudClean.im_subrng" href="#CloudClean.im_subrng"><code>CloudClean.im_subrng</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">im_subrng(jx,jy,cx,cy,sx,sy,px0,py0,stepx,stepy,padx,pady,tilex,tiley) -&gt; xrng, yrng, star_ind</code></pre><p>Computes the flux a star must have so that the PSF-based masking using <code>thr</code> would require a larger stamp area. Used for computational savings.</p><p><strong>Arguments:</strong></p><ul><li><code>jx</code>: tile index along x</li><li><code>jy</code>: tile index along y</li><li><code>cx</code>: list of stellar x-coordinates</li><li><code>cy</code>: list of stellar y-coordinates</li><li><code>sx</code>: size of original image in x</li><li><code>sy</code>: size of original image in y</li><li><code>px0</code>: maximal padding in x to account for stars outside image</li><li><code>py0</code>: maximal padding in y to account for stars outside image</li><li><code>stepx</code>: tiling step size in x</li><li><code>stepy</code>: tiling step size in y</li><li><code>padx</code>: tile padding in x required to account for local stamp size, sample size, and pixels outside the image</li><li><code>pady</code>: tile padding in x required to account for local stamp size, sample size, and pixels outside the image</li><li><code>tilex</code>: total number of tile divisions along x</li><li><code>tiley</code>: total number of tile divisions along y</li></ul><p><strong>Outputs:</strong></p><ul><li><code>xrng</code>: slicing range of the tile in x</li><li><code>yrng</code>: slicing range of the tile in y</li><li><code>star_ind</code>: Bool mask of all stars falling within the tile (subimage)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudClean.jl/blob/0b5d67ae6d3498b479a5fd1eb28c0e8a01de2cd1/src/preprocess.jl#L108-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudClean.add_sky_noise!" href="#CloudClean.add_sky_noise!"><code>CloudClean.add_sky_noise!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_sky_noise!(testim2, maskim, sig_iqr; seed=2021)</code></pre><p>Add sky noise to pixels in an image specified by a given mask.</p><p><strong>Arguments:</strong></p><ul><li><code>testim2</code>: A mutable 2D array representing the image.</li><li><code>maskim</code>: A 2D array representing the mask.</li><li><code>sig_iqr</code>: The standard deviation of the noise distribution, generally calculated as the normalized IQR.</li></ul><p><strong>Keywords:</strong></p><ul><li><code>seed</code>: An optional integer specifying the random number generator seed (default: 2021).</li></ul><p><strong>Returns:</strong></p><ul><li>Modifies <code>testim2</code> in place by adding sky noise to the masked pixels.</li></ul><p><strong>Examples:</strong></p><pre><code class="language-julia hljs">julia&gt; testim2 = rand(100, 100)
julia&gt; maskim = rand(Bool, 100, 100)
julia&gt; sig_iqr = 0.5
julia&gt; add_sky_noise!(testim2, maskim, sig_iqr, seed=2021)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudClean.jl/blob/0b5d67ae6d3498b479a5fd1eb28c0e8a01de2cd1/src/preprocess.jl#L52-L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudClean.add_noise!" href="#CloudClean.add_noise!"><code>CloudClean.add_noise!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_noise!(testim2,gain;seed=2021)</code></pre><p>Adds noise to an image that matches the Poisson noise of the pixel counts. A random seed to set a local random generator is provided for reproducible unit testing.</p><p><strong>Arguments:</strong></p><ul><li><code>testim2</code>: input image which had infilling</li><li><code>gain</code>: gain of detector to convert from photon count noise to detector noise</li></ul><p><strong>Keywords:</strong></p><ul><li><code>seed</code>: random seed for random generator</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudClean.jl/blob/0b5d67ae6d3498b479a5fd1eb28c0e8a01de2cd1/src/preprocess.jl#L32-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudClean.kstar_circle_mask" href="#CloudClean.kstar_circle_mask"><code>CloudClean.kstar_circle_mask</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">kstar_circle_mask(Np;rlim=256) -&gt; circmask</code></pre><p>Generates a Bool mask for pixels beyond a given (squared) radius of the center of an image.</p><p><strong>Arguments:</strong></p><ul><li><code>Np</code>: size of image stamp</li></ul><p><strong>Keywords:</strong></p><ul><li><code>rlim</code>: squared radius (in pixels^2) beyond which pixels should be masked (default 256)</li></ul><p><strong>Outputs:</strong></p><ul><li><code>circmask</code>: static Bool mask used for assigning pixels beyond some radius of the stellar center as &quot;ignored&quot;</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudClean.jl/blob/0b5d67ae6d3498b479a5fd1eb28c0e8a01de2cd1/src/preprocess.jl#L86-L99">source</a></section></article><h2 id="Full-Image-Processing-Functions"><a class="docs-heading-anchor" href="#Full-Image-Processing-Functions">Full Image Processing Functions</a><a id="Full-Image-Processing-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Full-Image-Processing-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CloudClean.proc_discrete" href="#CloudClean.proc_discrete"><code>CloudClean.proc_discrete</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">proc_discrete(x_locs, y_locs, raw_image, mask_image; Np=33, widx=129, widy=widx, tilex=1, tiley=tilex, seed=2021, ftype::Int=32, ndraw=0) -&gt; out_mean, out_draw</code></pre><p>Process an image with a mask, replacing masked pixels with either a mean or draw from a distribution resembling the local pixel-pixel covariance structure in the image.</p><p><strong>Arguments:</strong></p><ul><li><code>x_locs</code>: A 1D array representing the location centers (in the x coordinate) for infilling.</li><li><code>y_locs</code>: A 1D array representing the location centers (in the y coordinate) for infilling.</li><li><code>raw_image</code>: A 2D array representing the input image.</li><li><code>mask_image</code>: A 2D array representing the mask.</li></ul><p><strong>Keywords:</strong></p><ul><li><code>Np</code>: An optional integer specifying the number of pixels in a side (default: 33).</li><li><code>widx</code>: An optional integer specifying the width of the region used for training the local covariance in the x-direction (default: 129).</li><li><code>widy</code>: An optional integer specifying the width of the region used for training the local covariance in the y-direction (default: widx).</li><li><code>tilex</code>: An optional integer specifying the number of tiles in the x-direction for subdividing the image (default: 1).</li><li><code>tiley</code>: An optional integer specifying the number of tiles in the y-direction for subdividing the image (default: tilex).</li><li><code>seed</code>: An optional integer specifying the random number generator seed (default: 2021).</li><li><code>ftype</code>: An optional integer specifying the floating-point precision type (32 or 64) (default: 32).</li><li><code>rlim</code>: Radius limit for the radial mask beyond which pixels are not used for conditioning (units are pixels^2). (default: 625)</li><li><code>ndraw</code>: An optional integer specifying the number of draws of samples from the statistical distribution of possible masked pixel values (default: 0).</li></ul><p><strong>Returns</strong></p><ul><li>If <code>ndraw</code> is 0, returns the debiased image as a 2D array.</li><li>If <code>ndraw</code> is greater than 0, returns the debiased image as a 2D array and an array of <code>ndraw</code> draws.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; raw_image = rand(100, 100)
julia&gt; mask_image = kstar_circle_mask(100,rlim=256)
julia&gt; result = proc_continuous([50],[50],raw_image, mask_image, Np=33, widx=129, seed=2021)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudClean.jl/blob/0b5d67ae6d3498b479a5fd1eb28c0e8a01de2cd1/src/process.jl#L167-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CloudClean.proc_continuous" href="#CloudClean.proc_continuous"><code>CloudClean.proc_continuous</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">proc_continuous(raw_image, mask_image; Np=33, widx=129, widy=widx, tilex=1, tiley=tilex, seed=2021, ftype::Int=32, ndraw=0) -&gt; out_mean, out_draw</code></pre><p>Process an image with a mask, replacing masked pixels with either a mean or draw from a distribution resembling the local pixel-pixel covariance structure in the image.</p><p><strong>Arguments:</strong></p><ul><li><code>raw_image</code>: A 2D array representing the input image.</li><li><code>mask_image</code>: A 2D array representing the mask.</li></ul><p><strong>Keywords:</strong></p><ul><li><code>Np</code>: An optional integer specifying the number of pixels in a side (default: 33).</li><li><code>widx</code>: An optional integer specifying the width of the region used for training the local covariance in the x-direction (default: 129).</li><li><code>widy</code>: An optional integer specifying the width of the region used for training the local covariance in the y-direction (default: widx).</li><li><code>tilex</code>: An optional integer specifying the number of tiles in the x-direction for subdividing the image (default: 1).</li><li><code>tiley</code>: An optional integer specifying the number of tiles in the y-direction for subdividing the image (default: tilex).</li><li><code>seed</code>: An optional integer specifying the random number generator seed (default: 2021).</li><li><code>ftype</code>: An optional integer specifying the floating-point precision type (32 or 64) (default: 32).</li><li><code>ndraw</code>: An optional integer specifying the number of draws of samples from the statistical distribution of possible masked pixel values (default: 0).</li></ul><p><strong>Returns</strong></p><ul><li>If <code>ndraw</code> is 0, returns the debiased image as a 2D array.</li><li>If <code>ndraw</code> is greater than 0, returns the debiased image as a 2D array and an array of <code>ndraw</code> draws.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; raw_image = rand(100, 100)
julia&gt; mask_image = rand(Bool, 100, 100)
julia&gt; result = proc_continuous(raw_image, mask_image, Np=33, widx=129, seed=2021)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andrew-saydjari/CloudClean.jl/blob/0b5d67ae6d3498b479a5fd1eb28c0e8a01de2cd1/src/process.jl#L6-L35">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 5 July 2023 00:45">Wednesday 5 July 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
